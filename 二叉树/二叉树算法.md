[toc]

**二叉树的题目的分类解法**

- 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点；
- 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算；
- 求二叉搜索树的属性，一定是中序


## 1.二叉树的层序遍历

总结：二叉树层序遍历的题目，需要区分什么是需要前序遍历、什么时候需要中序遍历以及什么时候需要后序遍历

另外在层序遍历的时候，可以考虑队列的先进先出的特点，或者利用栈先进后出的特点

https://leetcode-cn.com/problems/binary-tree-level-order-traversal
题目
二叉树：[3,9,20,null,null,15,7],

```
    3
   / \
  9  20
    /  \
   15   7
```
返回其层序遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

<img src="img/tree_level_1.png">

解题思路：

- 1. 使用递归
- 2. 使用队列

### **方法一: 使用递归**

使用递归返回的难点是：

- 确定递归函数的参数、是否需要返回值
- 确定终止条件
- 确定遍历的序列，是用前序遍历、中序遍历还是后序遍历

#### 确定递归函数
将当前层的所有子节点作为下一次调用的输入

递归函数看题目需要什么，有时候需要传路径或结果进去 [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```java
 void recursiveLevelTraversal(List<TreeNode> currentLevelList, List<List<Integer>> result)
```

确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

**如果需要搜索整颗二叉树，那么递归函数就不要返回值值，如果要搜索其中一条符合条件的路径，递归函数需要返回值，因为遇到符合条件的路径就要及时返回。**

例子：

- 需要返回值的，[112. 路径总和](https://github.com/yxhuangCH/LeetCode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/tree/src/main/java/com/yxhuang/tree/TreeHasPathSum.java)
- 不需要返回值的，[113. 路径总和 II](https://github.com/yxhuangCH/LeetCode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/tree/src/main/java/com/yxhuang/tree/TreePathSum.java)

#### 递归结束条件

 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或终止条件写的不对导致的。

```java
 // 判断条件
if (currentLevelList.size() == 0) {
    return;
}
```
#### 递归层中的逻辑

在每一层需要做三件事

- 1. 每层中需要遍历这一层的所有子节点
- 2. 将这些子节点添加到列表中，作为下一次调用的输入
- 3. 这层节点添加到这层的列表中，并添加到 result 中

```
private static void recursiveLevelTraversal(List<TreeNode> currentLevelList, List<List<Integer>> result) {
    // 判断条件
    if (currentLevelList.size() == 0) {
        return;
    }
    // 下一层需要判断的节点
    List<TreeNode> levelList = new ArrayList<>();
    // 当前层的结果
    List<Integer> levelResult = new ArrayList<>(currentLevelList.size());
    for (TreeNode node : currentLevelList) {
        levelResult.add(node.val);
        if (node.left != null) {
            levelList.add(node.left);
        }
        if (node.right != null) {
            levelList.add(node.right);
        }
    }
    // 把当前层的结果添加到返回结果中
    result.add(levelResult);
    // 再次调用递归函数
    recursiveLevelTraversal(levelList, result);
}
```

### 方法二：使用迭代法
方法二是在方法一的基础上进一步改进,将递归改成迭代，每一层将原来使用数组改成用队列的方式，队列先进先出的特点，刚好适合每层从做到右的特点

```java
// 使用队列的版本
private static List<List<Integer>> levelTraversal2(TreeNode root) {
    if (root == null) {
        return Collections.emptyList();
    }
    // 返回结果
    List<List<Integer>> result = new ArrayList<>();
    // 每一层的节点
    Queue<TreeNode> levelQueue = new ArrayDeque<TreeNode>();
    // 先添加第一层
    levelQueue.add(root);

    while (!levelQueue.isEmpty()) {
        // 每层的节点数量
        int levelNodeSize = levelQueue.size();
        // 每一层的节点
        List<Integer> levelNode = new ArrayList<>(levelNodeSize);
        for (int i = 0; i < levelNodeSize; i++) {
            TreeNode node = levelQueue.poll();
            if (node == null) {
                break;
            }
            if (node.left != null) {
                levelQueue.add(node.left);
            }
            if (node.right != null) {
                levelQueue.add(node.right);
            }
            levelNode.add(node.val);
        }
        // 每一层的结果添加到结果中
        result.add(levelNode);
    }

    return result;
}
```
[完整的解题代码](https://github.com/yxhuangCH/LeetCode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/tree/src/main/java/com/yxhuang/tree/level/TreeLevelTraversalPractice.java)


## 2. 构建二叉树

### 构建的思路：
以后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来在切后序数组。一层一层切下去，每次后序最后一个元素就是节点元素。

### 步骤：
- 第一步：如果数组大小为 0 的话，说明是空节点；
- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素；
- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点；
- 第四步：切割中序数组，切成中序做数组和中序右数组(顺序一定要对，一定是先切中序数组)
- 第五步：切割后序数组，切成后序做数组和后序数组；
- 第六步：递归处理左区间和右区间。

### 模板

```java
public static TreeNode buildTree(int[] inorder, int[] postorder) {
    // 第一步
    if (postorder.length == 0){
        return null;
    }

    // 第二步，后序遍历数组最后一个元素，就是当前的中间节点
    int rootValue = postorder[postorder.length -1];
    TreeNode node = new TreeNode(rootValue);

    // 叶子节点
    if (postorder.length == 1){
        return node;
    }

    // 第三步，找切割点
    int delimiterIndex;
    for (delimiterIndex = 0; delimiterIndex < inorder.length; delimiterIndex++){
        if (inorder[delimiterIndex] == rootValue){
            break;
        }
    }

    // 第四步：切割中序数组，得到 中序左数组和中序右数组
    // 左闭右开 [0, delimiterIndex]
    int[] leftInorder = Arrays.copyOfRange(inorder, 0, delimiterIndex);
    int[] rightInorder = Arrays.copyOfRange(inorder, delimiterIndex + 1, inorder.length );

    // 去掉最后一个元素
    postorder = Arrays.copyOfRange(postorder, 0, postorder.length -1);

    // 第五步：切割后序数组，得到 后序左数组和后序右数组
    //  左闭右开， 注意这里用左中数组大小作为切割点
    int[] leftPostorder = Arrays.copyOfRange(postorder,0, leftInorder.length);
    int[] rightPostorder = Arrays.copyOfRange(postorder, leftInorder.length, postorder.length);


    // 第六步：
    node.left = buildTree(中序左数组，后序左数组);
    node.left = buildTree(中序右数组，后序右数组);
    
    return node;
}
```
具体的代码见 [TreeBuildTree_105](https://github.com/yxhuangCH/LeetCode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/tree/src/main/java/com/yxhuang/tree/TreeBuildTree_105.java)

如果是前序数组和中序数组，则用前序数组切割中序数组，具体的代码见 [TreeBuildTree_106](https://github.com/yxhuangCH/LeetCode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/tree/src/main/java/com/yxhuang/tree/TreeBuildTree_106.java)



### 构建一个最大的二叉树

> 二叉树的根是数组 nums 中的最大元素。
左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树


原题：https://leetcode-cn.com/problems/maximum-binary-tree

思路：使用递归和双指针
详见 [TreeConstructMaximumBinaryTree_654](https://github.com/yxhuangCH/LeetCode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/tree/src/main/java/com/yxhuang/tree/TreeConstructMaximumBinaryTree_654.java)












